# electron_field_simulation.py
# Simulation of the dynamics of an electron in an electric field generated by a charged ring

import numpy as np

# Constants
PI = np.pi
K_COULOMB = 8.9875517873681764e9  # Coulomb constant (N*m^2/C^2)
ELECTRON_MASS = 9.11e-31  # Electron mass (kg)
ELECTRON_CHARGE = -1.602176634e-19  # Electron charge (C)

class Ring:
    def __init__(self, n_charges, radius, total_charge):
        """
        Initialize a charged ring.
        
        Parameters:
        - n_charges: number of charge particles distributed along the ring.
        - radius: radius of the ring.
        - total_charge: total charge on the ring.
        """
        self.n_charges = n_charges
        self.radius = radius
        self.total_charge = total_charge
        self.charge_per_particle = total_charge / n_charges  # Charge per particle in the ring
        self.positions = self._compute_positions()  # Compute the positions of the charges in the ring

    def _compute_positions(self):
        """Calculates the positions of the particles on the ring."""
        positions = []
        theta_step = 2 * PI / self.n_charges  # Angle step for charge distribution
        for i in range(self.n_charges):
            theta = i * theta_step
            y = self.radius * np.cos(theta)  # Y-coordinate
            z = self.radius * np.sin(theta)  # Z-coordinate
            positions.append([0, y, z])  # Assumed to be in the YZ plane
        return np.array(positions)

class Electron:
    def __init__(self, position, velocity):
        """
        Initialize an electron with position and velocity.

        Parameters:
        - position: initial position of the electron as a list or array of [x, y, z].
        - velocity: initial velocity of the electron as a list or array of [vx, vy, vz].
        """
        self.position = np.array(position, dtype=float)
        self.velocity = np.array(velocity, dtype=float)

class Simulation:
    def __init__(self, electron, ring, dt, total_time):
        """
        Initialize the simulation.

        Parameters:
        - electron: the Electron object being simulated.
        - ring: the Ring object creating the electric field.
        - dt: time step for the simulation (in seconds).
        - total_time: total simulation time (in seconds).
        """
        self.electron = electron
        self.ring = ring
        self.dt = dt
        self.total_time = total_time
        self.time = 0
        self.energy_data = []  # Stores the energy data for each time step

    def _compute_electric_field(self):
        """
        Calculates the total electric field at the electron's position due to the charged ring.

        Returns:
        - total_field: the electric field vector at the electron's position.
        """
        total_field = np.zeros(3)  # Initialize the electric field as a zero vector
        for charge_position in self.ring.positions:
            r_vector = self.electron.position - charge_position  # Vector from charge to electron
            distance = np.linalg.norm(r_vector)  # Distance between the electron and the charge
            if distance == 0:
                continue  # Skip if the electron is at the same position as a charge
            field_magnitude = K_COULOMB * self.ring.charge_per_particle / distance**2  # Coulomb's law
            field_vector = field_magnitude * (r_vector / distance)  # Electric field vector
            total_field += field_vector  # Sum the field contributions
        return total_field

    def _update_position_and_velocity(self):
        """
        Updates the electron's position and velocity using the Euler method.
        The position and velocity are updated according to the electric field.
        """
        electric_field = self._compute_electric_field()  # Get the electric field at the electron's position
        acceleration = (electric_field * ELECTRON_CHARGE) / ELECTRON_MASS  # Newton's second law
        self.electron.velocity += acceleration * self.dt  # Update velocity based on acceleration
        self.electron.position += self.electron.velocity * self.dt  # Update position based on velocity

    def _compute_energies(self):
        """
        Computes the kinetic and potential energies of the electron.

        Returns:
        - kinetic_energy: the kinetic energy of the electron.
        - potential_energy: the potential energy of the electron due to the ring's charges.
        - total_energy: the total energy (kinetic + potential) of the electron.
        """
        kinetic_energy = 0.5 * ELECTRON_MASS * np.linalg.norm(self.electron.velocity)**2  # Kinetic energy
        potential_energy = 0  # Initialize potential energy
        for charge_position in self.ring.positions:
            r_vector = self.electron.position - charge_position  # Vector from charge to electron
            distance = np.linalg.norm(r_vector)  # Distance between the electron and the charge
            if distance != 0:
                potential_energy += ELECTRON_CHARGE * self.ring.charge_per_particle * K_COULOMB / distance  # Potential energy
        total_energy = kinetic_energy + potential_energy  # Total energy (kinetic + potential)
        return kinetic_energy, potential_energy, total_energy

    def run(self):
        """
        Runs the simulation by iteratively updating the electron's position and velocity.

        Returns:
        - energy_data: list of energy data over time.
        """
        while self.time < self.total_time:
            self._update_position_and_velocity()  # Update position and velocity
            energies = self._compute_energies()  # Compute the energies at the current time step
            self.energy_data.append((self.time, *energies))  # Store the energy data
            self.time += self.dt  # Increment the time

        return self.energy_data

if __name__ == "__main__":
    # Initial configuration
    electron = Electron(position=[0.15, 0.0, 0.0], velocity=[0.0, 0.0, 0.0])  # Initial electron position and velocity
    ring = Ring(n_charges=100, radius=0.1, total_charge=50e-9)  # Ring with 100 charges, radius 0.1 m, total charge 50 nC
    simulation = Simulation(electron=electron, ring=ring, dt=1e-17, total_time=1e-5)  # Create simulation with time step 1e-17s

    # Run the simulation
    energy_data = simulation.run()

    # Print results in a readable format
    print("Time(s)    Kinetic Energy(J)    Potential Energy(J)    Total Energy(J)")
    for data in energy_data:
        print(f"{data[0]:.2e}    {data[1]:.2e}    {data[2]:.2e}    {data[3]:.2e}")
